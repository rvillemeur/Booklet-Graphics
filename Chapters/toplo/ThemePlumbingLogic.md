## Stylesheets and Skins

Toplo widgets are fully skinnable. All their visual aspects can be controlled via stylesheets. Stylesheets are composed of rules. Such rules are manipulate token properties. In addition, an element gets a skin, a selection of the stylesheet rules that apply to the element. 


### Extended Bloc phases

A graphic element (**BlElement**) has properties such as its color, a transformation matrix, a border value, layout rules, and so on. 
If the graphic element is a text, it can have a font name, font size, ... A graphic element can be animated, i.e. its properties can be modified with time-based events. A graphic element can have *event handlers* that enable the element to react according to events (e.g. adding a new element inside the graphic element, clicking on it with the mouse, etc.). A graphic element can contain other graphic elements. To display a graphic element on the screen, it must be added to a *space* (**BlSpace**).

A space contains a *frame* that manages the various stages of drawing and event/animation management in Bloc. 
A frame is made up of different phases. When the "space" receives a *pulse*, the frame calls all the `#runOn:` methods of each phase on the space in turn. 
The phases are :

1. **Idle:** Do nothing. This is a waiting phase when the space has nothing to do.
2. **Host Validation:** Creates a new window when Pharo is launched. This mechanism is not currently used. I suppose it's complicated to implement with external libraries such as Cairo, which need to create a new handler each time the graphical environment is started.
3. **Task:** Triggers time-based events. The animations for example.
4. **Event:** Updates the focus of elements in the space, then retrieves events from the window (mouse, keyboard, zoom, etc.) and sends them to the various elements in the space.
5. **Drawing Validation:** Checks whether the window needs to redraw elements. For example, if the window has changed size.
6. **Layout:** Computes the layout of the various elements.
7. **Drawing:** Orders the renderer to draw the various elements.

Toplo will add 2 new phases to this list, between the Drawing Validation and Layout phases. These two phases are :

51. **Skin Installer:** Checks if a new skin should be installed on graphic elements. If so, it will recalculate the layout, uninstall the old skin and install the new one.
52. **Skin State Application:** Creates look events based on the state of graphic elements.

These two phases are added to a space when an element requests the installation of a new skin for the first time.


### How StyleSheets in a nutshell

Each graphic element has a skin manager. The role of this manager is to install skins on the graphic element, i.e. to update the element's properties according to its state. Graphic element states are divided into three categories:

* **Management states:** These states manage skin installation and uninstallation, as well as element enablement.
* **Intrinsic states:** These are states that are inseparable from the object, for example when the object is "focus", or "checked" in the case of a "checkbox button".
* **Transient states:** These are non-persistent states. For example, if the element is hovered, or if it is pressed, or if it is dragged, etc.

States are generated by an event handler (`ToSkinStateGenerator`) associated with the graphic element. 
Only elements with this event handler can receive skins.

When a new skin is installed, the skin manager adds an event handler to the graphic element. 
This event handler is a `ToStyleSheetSkin`. This event handler manages look events (`ToElementLookEvent`). 
It uses the element's *writers* to update the properties of the element.

Look events are events created during the *SkinStateApplication phase* based on the current state of the graphic element. There are 3 categories of look events: management events (skin installation and uninstallation), intrinsic events (focus/unfocus, checked/unchecked, etc.) and transient events (pressed, drag, hover, etc.).

Element's *writers* are *ToLookEventListener* and are described in the skin *theme*. They correspond to the set of style rules for the graphic element.

There are two ways to install a new skin for a graphic element. It's possible to apply a new theme to all the graphic elements in a space. It's also possible to update an element's *tokens* or *stamps*, in which case the skin of the children's element will also be replaced by an updated version.

Each graphic element stores its tokens and stamps in a *store* (`ToStyleStore`). Tokens and stamps are key-value associations. They can be accessed by the element's writers. There are two differences between tokens and stamps:

* When a graphic element is asked if it contains a token (using its key), it will look for it in its own store. If its store doesn't contain the token, it will ask its parent's store (and so on, all the way back to the root element). If it doesn't found it, it will raised an exception. When a graphical element is asked if it contains a stamp, it will only look in its own store.
* A stamp, unlike a token, can be used as a selector by a theme's style rules.


### How theme works?

A theme can be applied to a space to quickly modify the appearance of the graphic elements it contains. A theme contains a variant, a list of editable properties and style rules.
Editable properties are a list of properties that the theme allows you to modify; an editable property is not necessarily a property of a graphic element. There are two types of editable property:

* **Feature:** when the property has the same name in the theme as in the API of the graphic element (e.g. width, height, layout, label, geometry, etc.). In this case, the writer uses the graphic element's API to update the graphic appearance.
* **Pseudo:** When the property in the theme does not correspond to a property in the graphic element (e.g. background-color, border-with-builder, label-text-background, etc.). Pseudos can be used to modify a widget's child elements directly at widget level, or to access properties not present in the graphical element API in the form of a facade (e.g. change text color).

Theme variants allow you to change the values of certain tokens in the space's root element. When a theme is applied to a space, the root element of the space receives from the theme a list of all tokens used in the theme. Theme variants can be used to change the value of some theme tokens, for example the tokens used for the colors, making it easy to create a *light* theme and a *dark* theme.

A style rule is an association between a selector and one or more writers. A rule can only be applied to a graphic element if the rule's selector corresponds to the graphic element. There are 5 types of selector, and they can be combined with different operators. The five selector types are:

* **Any:** Selects any element.
* **Action:** Evaluates a *block closure* with the graphic element as argument. If the block returns true, then the element is selected, otherwise it is not.
* **Type:** Used to test whether the graphic element is an object of a given class. For example, it can check that the graphic element is a **ToButton**.
* **Id:** Selects graphic elements according to their *id*. The id is a BlElement's property.
* **Stamp:** Checks that the graphic element has a stamp with a given key.

Selectors can be combined together using different operators. There are 6 different operators:

* **Not:** Negates the selection.
* **And:** Boolean combination of *and* between two selectors.
* **Or:** Boolean *or* combination between two selectors.
* **Child:** Used to apply a selector to the graphic element's children. It is possible to set a child depth level.
* **Parent:** Allows you to apply a selector to the graphic element's parent. It is possible to set a parent depth level.
* **Sibling:** Allows you to apply a selector to graphic elements having the same parent as the graphic element.

All selectors and combinations are interpreted by **ToSelectorInterpreter** each time a theme is installed on a space. If the selector "matches" with one of the graphic elements, the associated writers are installed on the element. By default, only the last writter per editable property and look event is installed for a given graphic element. You can force a rule to be applied using the *supplements* variable.

Writers are `ToLookEventListeners`. They respond to look events. Writers modify the editable properties of each graphic element. Style rules and their associated writers are built by a *scripter* (`TToStyleRuleScripter`). To create a style rule, use the `#select:style:` method, with a selector for the rule as the first argument and a block closure that executes the associated writers as the second argument. The scripter has 8 different methods for creating writers:

* `#do:` - Executes a block with the element selected when the skin is installed as argument.
* `#when:do:` - Executes a block with the selected element as argument for a given look event.
* `#write:with:` - Modifies an editable property with the given value.
* `#write:whitAll:` - Modifies a list of editable properties with the given values.
* `#when:write:with:` - Modifies an editable property with the given value for a given look event.
* `#when:write:with:animation:` - Modifies an editable property with the given value and associated animation for a given look event.
* `#supplement:with:` - Forces the modification of an editable property with the given value.
* `#when:supplement:with:` - Forces the modification of an editable property with the given value for a given look event.


### Core elements

A stylesheet is composed of rules and token properties. Tokens are kind of variables holding values. Rules are kinds of declarations and event condition actions.

An element gets a skin. A Skin is a selection of rules and values dedicated 
to the element. A skin is a handler that will react of events.
At the implementation level there are two kinds of skins: raws that are defined by mere classes and rule-based ones that are a selection of the rules that apply to the element.


### Token Property

A Token is a piece of information associated with a name, at minimum a name/value pair. The name may be associated with additional token properties.
There are different types of token properties: the basic one (`ToTokenProperty`), using accessors of an element (`ToFeatureProperty`), and pseudo properties based on function definitions (`ToPseudoProperty`).

Token properties allow one to define key/value pairs and are read-only.

```
ToTokenProperty 
	name: #'background-color' 
	value: Color white
```
or
```
ToTokenProperty 
	name: #'border-radius' 
	value: 6
```

These properties can later be used in stylesheets to connect `BlElement`
properties to token properties. 

You can set token directly on an element using the method `setToken: anAssociation` or 
`setTokenNamed:value:`.

```
anElt setToken: #'color-primary' -> Color random.
anElt 
	setTokenNamed: #'color-primary-pressed' 
	value: Color random twiceDarker
```

### Feature and Pseudo properties

Property are also declined into feature property (`ToFeatureProperty`) and Pseudo property (`ToPseudoProperty`). 

Skin managing needs a list of unique writeable properties defined in `ToStyleSheet class >> defaultWritablePropertyList`.

These properties can read or write values. Writing means changing a property
on a `BlElement`.

#### Feature property.
`ToFeatureProperty` links to an object feature accessor (getter/setter).

```
(ToFeatureProperty name: #background).
(ToFeatureProperty name: #geometry).
(ToFeatureProperty name: #border).
(ToFeatureProperty name: #size).
(ToFeatureProperty name: #layout).
```



#### Pseudo property.
A pseudo property is a block-based mapper in the sense that it defines 
two functions to control the logic of the property where
- reader receives an object and returns a value
- writer receives an object and a property value


```
ToPseudoProperty 
	name: #'layout-direction'
	reader: [ :e | e layout direction ]
	writer: [ :e :v | e layout direction: v ]
```
```
(ToPseudoProperty name: #'layout-constraints'
	reader: [ :e | e constraints ]
	writer: [ :e :v | v value: e constraints ])
```

### Examples of properties and usage

```smalltalk
self 
	select: (self id: #'Space root') 
	style: [
		self
		write: (self property: #background)
		with: [ :e | e tokenValueNamed: #'background-color' ] ]
```

 is linked with the feature property `#background`

 ```
 (ToFeatureProperty name: #background).
 ```
 and the token #'background-color' 
 ```
 (ToTokenProperty name: #'background-color' value: Color white).
 ```
 

```smalltalk
ToButton asTypeSelector 
	style: [ :sr |
	"Background"
	sr
		when: ToInstallLookEvent
		write: (self property: #'background-color')
		with: [ :e | e tokenValueNamed: #'color-bg-container' ].
	sr
		when: ToDisabledLookEvent
		write: (self property: #'background-color')
		with: [ :e | e tokenValueNamed: #'color-bg-container-disabled' ].
 	]
```

is linked with the pseudo property

```smalltalk
(ToPseudoProperty name: #'background-color'
        reader: [ :e | e background paint 
        	ifNotNil: [ :f | f color ] 
	ifNil:[ Color transparent ] ]
        writer: [ :e :v | e background: v ]).
```

and the following token 

```
ToTokenProperty 
	name: #'color-bg-container' 
	value: (Color fromHexString: '#ffffff')
ToTokenProperty 
	name: #'color-bg-container-disabled' 
	value: (Color black alpha: 0.04)
```


Finally 

```smalltalk
self
	when: ToDisabledLookEvent
	write: (self property: #'text-attributes-with-builder')
	with: [ :e |
		e textAttributesBuilder foreground:
			(e tokenValueNamed: #'color-text-disabled') ].

self 
	select: #H1 asStampSelector 
	style: [
		self 
			supplement: (self property: #'text-attributes-with-builder')
			with: [ :e |
				e textAttributesBuilder
					defaultFontSize: (e tokenValueNamed: #'font-size-H1');
					lineSpacing: (e tokenValueNamed: #'line-height-H1');
					yourself ] ].
```

### Another example of property definition

```smalltalk
(ToPseudoProperty new name: #'text-attributes-with-builder';
	writer: [ :e :v |
		e text attributes: v attributes.
		e textChanged ]).
```

```smalltalk
self
	select: (#'labeled-icon' asStampSelector
                	withParent: #button asStampSelector
                	atDepth: 1)
	style: [
		self
			write: (self property: #layout)
			with: [ :e | BlLinearLayout horizontal].
        		self 
			write: (self property: #'layout-constraints') 
			with: [ :c |
			c horizontal fitContent.
 			c vertical fitContent.
            			c linear vertical alignCenter.
            			c linear horizontal alignCenter ] ].
    ]
```



### Style sheet definition

Styles are defined vis  `select:style:`messages with multiple arguments.

`select:` lets you select a specific element. You can look at various attribute
selection below. You can even refine your selection through parent or child,
with the following element element selection.
Element selection is managed by `ToElementSelector`.

#### Type selection
Type selector are selection based on the class of the BlElement. 
Using the message `asTypeSelector any element class can play this role.

`ToLabel asTypeSelector` or `ToButton asTypeSelector`
or you can use `type:` as in `ToTypeSelector new type: ToElement`

#### Id selection
The selection can also be based on the id of an element. 

- element definition as in  `ToButton id: #buttonA`
- element query as in `id: #buttonA`

#### Stamp selection
The selection can be based on specific stamp attached to an element.

- element definition as in:  `ToButton new addStamp: #'primary'.`
- element query as in: `#primary asStampSelector`

You can also use `removeStamp:` as well to change a stamp.

#### Child, parent or sibling selection

Each selection will accept another selector to refine your current element search.

- `withChild:`
- `withChild:atDepth:`
- `withParent:`
- `withParent:atDepth:`
- `withSibling:`

#### Selection composition
Finally selection can be composed with traditional boolean logic operators:

- And selector `&&`
- Or selector `||`
- Inverse selector `not`

```
ToButton asTypeSelector && #primary asStampSelector
```

You can also target a child or parent of your element.

### Style definition

Style will be passed a Block to define specific style attribute.

- `write:with:`, if you only want to define a property.
- `supplement:with:` if you want to add additional properties to your element.
- `when:write:with:` associates a property change during an event.
- `when:supplement:with:` associates additional property change during an event.
- `when:write:with:animation:` associates change to an event and with an animation

The message arguments follow:
- `when:` argument is a look event, part of the list `ToElementLookEvent allSubclasses`
- `write:` and `supplement:` argument will get the property to change
- `with:` argument is a block whose parameter is the element that needs to
be changed.
- `animation:` argument is a subclass of `ToPropertyAnimation`. The animation must be
shared by all writers that are using it to stop it correctly.

### Examples

```smalltalk
backgroundColorAnim := ToPropertyColorTransitionAnimation new
    duration: 150 milliSeconds.

select: self buttonSelector && #primary asStampSelector
style: [
    self
        when: ToInstallLookEvent
        write: (self property: #'background-color')
        with: [ :e | e tokenValueNamed: #'color-primary' ].
    self
        when: ToLeavedLookEvent
        write: (self property: #'background-color')
        with: [ :e | e tokenValueNamed: #'color-primary' ]
        animation: backgroundColorAnim.

    self
        when: ToInstallLookEvent
        write: (self property: #'border-with-builder')
        with: [ :e |
            e borderBuilder
                paint: Color transparent;
                width: (e tokenValueNamed: #'line-width') ].
]
```

### Selection example

```smalltalk
select: (#'labeled-icon' asStampSelector withParent: #button asStampSelector
    atDepth: 1)
```
